{"type":{"desc":"<p>将数据变换类型设置为 <code class=\"codespan\">treemap</code>，计算 treemap 布局</p>\n"},"gapWidth":{"desc":"<p>设置相同深度的两个节点之间的间距，支持两种格式的配置</p>\n<ul>\n<li><ol>\n<li>number 类型: 给所有层级的节点设置间距为指定的数值</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>number[] 数组类型: <code class=\"codespan\">number[i]</code>表示<code class=\"codespan\">depth = i</code>的节点之间的间距</li>\n</ol>\n</li>\n</ul>\n"},"padding":{"desc":"<p>类型：<code class=\"codespan\">number | number[]</code></p>\n<p>设置内边距，支持两种格式:</p>\n<ul>\n<li>number: 设置每一层的内边距</li>\n<li><code class=\"codespan\">number[]</code>: number[i] 表示 depth = i 的节点的 内边距</li>\n</ul>\n"},"aspectRatio":{"desc":"<p>设置宽高比，默认值为<code class=\"codespan\">(1 + Math.sqrt(5)) / 2</code>，仅当<code class=\"codespan\">splitType</code>为<code class=\"codespan\">squarify</code>时，有效果，其他划分算法不关心这个参数</p>\n"},"labelPadding":{"desc":"<p>对于非叶子节点，设置 label 的内边距，当且仅当有足够位置的时候，才会预留 label 展示的位置；\n可选值为：</p>\n<ul>\n<li><code class=\"codespan\">number</code>: 设置所有层级的 label 的内边距</li>\n<li><code class=\"codespan\">number[]</code>: number[i] 表示 depth = i 的节点的 label 的内边距</li>\n</ul>\n"},"labelPosition":{"desc":"<p>对于非叶子节点，设置 label 的位置，可选值为：</p>\n<ul>\n<li><code class=\"codespan\">&#39;top&#39;</code> 顶部</li>\n<li><code class=\"codespan\">&#39;bottom&#39;</code> 底部</li>\n<li><code class=\"codespan\">&#39;left&#39;</code> 左侧</li>\n<li><code class=\"codespan\">&#39;right&#39;</code> 右侧</li>\n</ul>\n<p>会根据这个配置，在相应的方向留下对应的空间后，再去计算子节点的划分</p>\n"},"splitType":{"desc":"<p>划分矩形的算法类型，可选值为：</p>\n<ul>\n<li><code class=\"codespan\">&#39;binary&#39;</code> 二分法</li>\n<li><code class=\"codespan\">&#39;squarify&#39;</code> squarify 算法</li>\n<li><code class=\"codespan\">&#39;slice&#39;</code> slice 算法，沿着水平方向划分</li>\n<li><code class=\"codespan\">&#39;dice&#39;</code> dice 算法，沿着垂直方向划分</li>\n<li><code class=\"codespan\">&#39;slice-dice&#39;</code> slice-dice 算法，水平方向-垂直方向交替换分</li>\n</ul>\n"},"nodeKey":{"desc":"<p>类型：<code class=\"codespan\">string|number</code>\n设置节点的全局唯一 key 对应的字段，如果不设置，内部会根据层级等信息自动生成</p>\n"},"maxDepth":{"desc":"<p>设置最大的深度，当节点的深度大于 maxDepth 时，不再计算下一层级的布局；这个配置可以不传</p>\n"},"minVisibleArea":{"desc":"<p>设置最小可见面积，当节点的面积小于 minVisibleArea 时，不再计算下一层级的布局；这个配置可以不传</p>\n"},"minChildrenVisibleArea":{"desc":"<p>设置子节点的最小可见面积，当节点的面积小于 <code class=\"codespan\">minChildrenVisibleArea</code> 时，这个子节点会被隐藏；这个配置可以不传；\n当值的类型为数组的时候，<code class=\"codespan\">minChildrenVisibleArea[i]</code> 表示 <code class=\"codespan\">depth = i</code> 的节点，对应的子节点的最小可见面积</p>\n"},"minChildrenVisibleSize":{"desc":"<p>设置子节点的最小可见尺寸，当节点的宽度或者高度小于 <code class=\"codespan\">minChildrenVisibleSize</code> 时，这个子节点会被隐藏；这个配置可以不传；\n当值的类型为数组的时候，<code class=\"codespan\">minChildrenVisibleSize[i]</code> 表示 <code class=\"codespan\">depth = i</code> 的节点，对应的子节点的最小可见尺寸</p>\n"}}