{"ordinal.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">ordinal</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"ordinal.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"ordinal.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n"},"band":{"desc":"<p><code class=\"codespan\">band</code> scale is mainly used to map discrete data to continuous intervals.</p>\n"},"band.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">band</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"band.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"band.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n"},"band.round":{"desc":"<p>Type: <code class=\"codespan\">ScaleFunctionType&lt;boolean&gt;</code>\nWhether to automatically round the segmented coordinates, supporting multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code></li>\n<li><code class=\"codespan\">function</code>, which accepts parameters <code class=\"codespan\">scale</code> and <code class=\"codespan\">params</code>, returning a <code class=\"codespan\">boolean</code> value</li>\n</ul>\n"},"band.padding":{"desc":"<p>Set the values of <code class=\"codespan\">paddingInner</code> and <code class=\"codespan\">paddingOuter</code> uniformly to one value</p>\n"},"band.paddingInner":{"desc":"<p>The proportion of padding between groups</p>\n"},"band.paddingOuter":{"desc":"<p>The proportion of outer padding</p>\n"},"band.align":{"desc":"<p>The alignment point, centered by default</p>\n"},"point.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">point</code>.</p>\n<!-- Syntax Element: data, DataSpec -->\n"},"point.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"point.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n"},"linear.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">linear</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"linear.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"linear.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"linear.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"linear.niceMin":{"desc":"<p>Optimize only the minimum value of the <code class=\"codespan\">domain</code>, keep the maximum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n"},"linear.niceMax":{"desc":"<p>Optimize only the maximum value of the <code class=\"codespan\">domain</code>, keep the minimum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"linear.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"linear.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"linear.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"linear.roundRange":{"desc":"<p>Whether to round the value range automatically</p>\n"},"linear.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"linear.config.clamp":{"desc":"<p>Range of clamp values</p>\n"},"linear.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"log.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">log</code></p>\n"},"log.log":{"desc":"<p>The base of the <code class=\"codespan\">log</code> function must be a positive number greater than 0, with the default value being 10.</p>\n<p>Supports two formats for settings</p>\n<ul>\n<li><code class=\"codespan\">number</code> type</li>\n<li><code class=\"codespan\">function</code> type, calculating the result through custom functions, and the ts type definition of the function is:</li>\n</ul>\n<pre><code>(scale: IBaseScale, parameters: any) =&gt; number;\n</code></pre><p>Where <code class=\"codespan\">parameters</code> are the other syntax elements that the scale syntax element depends on.</p>\n<!-- Syntax Element: data, DataSpec -->\n"},"log.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"log.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"log.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"log.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"log.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"log.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"log.roundRange":{"desc":"<p>Automatically round the range value</p>\n"},"log.config":{"desc":"<p><code class=\"codespan\">scale</code> configuration options</p>\n"},"log.config.clamp":{"desc":"<p>clamp the range value</p>\n"},"log.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"pow.type":{"desc":"<p>Set scale type to <code class=\"codespan\">pow</code></p>\n"},"pow.exponent":{"desc":"<p>Set the exponent for the power function</p>\n<p>Supports two formats for settings</p>\n<ul>\n<li><code class=\"codespan\">number</code> type</li>\n<li><code class=\"codespan\">function</code> type, calculating the result through custom functions, and the ts type definition of the function is:</li>\n</ul>\n<pre><code>(scale: IBaseScale, parameters: any) =&gt; number;\n</code></pre><p>Where <code class=\"codespan\">parameters</code> are the other syntax elements that the scale syntax element depends on.</p>\n<!-- Syntax Element: data, DataSpec -->\n"},"pow.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"pow.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"pow.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"pow.niceMin":{"desc":"<p>Optimize only the minimum value of the <code class=\"codespan\">domain</code>, keep the maximum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n"},"pow.niceMax":{"desc":"<p>Optimize only the maximum value of the <code class=\"codespan\">domain</code>, keep the minimum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"pow.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"pow.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"pow.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"pow.roundRange":{"desc":"<p>Whether to round range values automatically</p>\n"},"pow.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"pow.config.clamp":{"desc":"<p>Value range for clamp</p>\n"},"pow.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"sqrt.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">sqrt</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"sqrt.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"sqrt.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"sqrt.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"sqrt.niceMin":{"desc":"<p>Optimize only the minimum value of the <code class=\"codespan\">domain</code>, keep the maximum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n"},"sqrt.niceMax":{"desc":"<p>Optimize only the maximum value of the <code class=\"codespan\">domain</code>, keep the minimum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"sqrt.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"sqrt.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"sqrt.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"sqrt.roundRange":{"desc":"<p>Whether to round the value range automatically</p>\n"},"sqrt.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"sqrt.config.clamp":{"desc":"<p>Value range of clamp</p>\n"},"sqrt.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"symlog.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">symlog</code></p>\n"},"symlog.constant":{"desc":"<p>When the data is less than 0, the return value of <code class=\"codespan\">scale()</code> is set to this value</p>\n<p>Supports two formats for settings</p>\n<ul>\n<li><code class=\"codespan\">number</code> type</li>\n<li><code class=\"codespan\">function</code> type, calculating the result through custom functions, and the ts type definition of the function is:</li>\n</ul>\n<pre><code>(scale: IBaseScale, parameters: any) =&gt; number;\n</code></pre><p>Where <code class=\"codespan\">parameters</code> are the other syntax elements that the scale syntax element depends on.</p>\n<!-- Syntax Element: data, DataSpec -->\n"},"symlog.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"symlog.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"symlog.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"symlog.niceMin":{"desc":"<p>Optimize only the minimum value of the <code class=\"codespan\">domain</code>, keep the maximum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n"},"symlog.niceMax":{"desc":"<p>Optimize only the maximum value of the <code class=\"codespan\">domain</code>, keep the minimum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"symlog.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"symlog.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"symlog.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"symlog.roundRange":{"desc":"<p>Whether to round the value domain automatically</p>\n"},"symlog.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"symlog.config.clamp":{"desc":"<p>Value domain of clamp</p>\n"},"symlog.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"time.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">time</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"time.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"time.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"time.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"time.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"time.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"time.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"time.roundRange":{"desc":"<p>Whether to automatically round the value range</p>\n"},"time.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"time.config.clamp":{"desc":"<p>Value range of clamp</p>\n"},"time.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"utc.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">utc</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"utc.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"utc.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"utc.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"utc.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"utc.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"utc.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"utc.roundRange":{"desc":"<p>Whether to round the range automatically</p>\n"},"utc.config":{"desc":"<p>Configuration options for <code class=\"codespan\">scale</code></p>\n"},"utc.config.clamp":{"desc":"<p>Clamp the value range</p>\n"},"utc.config.interpolate":{"desc":"<p>Interpolation function</p>\n"},"quantile.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">quantile</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"quantile.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"quantile.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n"},"quantize.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">quantize</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"quantize.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"quantize.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n<!-- Syntax element data, DataSpec -->\n"},"quantize.nice":{"desc":"<p>For scale, calculate the optimized ticks and update the <code class=\"codespan\">domain</code> based on the tick values. It supports multiple types of values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: The number of optimized ticks</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"quantize.niceMin":{"desc":"<p>Optimize only the minimum value of the <code class=\"codespan\">domain</code>, keep the maximum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n"},"quantize.niceMax":{"desc":"<p>Optimize only the maximum value of the <code class=\"codespan\">domain</code>, keep the minimum value unchanged, and support multiple values:</p>\n<ul>\n<li><code class=\"codespan\">boolean</code>: <code class=\"codespan\">true</code> means automatic calculation, <code class=\"codespan\">false</code> means no optimization</li>\n<li><code class=\"codespan\">number</code>: indicates the number of ticks after optimization</li>\n</ul>\n<!-- Syntax elements data, DataSpec -->\n"},"quantize.zero":{"desc":"<p>For scale, calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>, and then update the value of <code class=\"codespan\">domain</code> in the following two cases:</p>\n<ul>\n<li>If the minimum value is greater than <code class=\"codespan\">0</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n<li>If the maximum value is less than <code class=\"codespan\">0</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">0</code></li>\n</ul>\n<p>When the user is very concerned about the base value of <code class=\"codespan\">0</code>, it can be set to <code class=\"codespan\">true</code>, with the default value being <code class=\"codespan\">false</code>.</p>\n"},"quantize.min":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the minimum value is greater than the user-configured <code class=\"codespan\">min</code>, set the minimum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">min</code>.</p>\n"},"quantize.max":{"desc":"<p>Calculate an original value range based on the data, which is the <code class=\"codespan\">domain</code>. If the maximum value is greater than the user-configured <code class=\"codespan\">max</code>, set the maximum value of <code class=\"codespan\">domain</code> to <code class=\"codespan\">max</code>.</p>\n"},"threshold.type":{"desc":"<p>Set the scale type to <code class=\"codespan\">threshold</code></p>\n<!-- Syntax Element: data, DataSpec -->\n"},"threshold.domain":{"desc":"<p>Set the domain of the <code class=\"codespan\">scale</code>, supporting two formats of settings:</p>\n<ul>\n<li>Object type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type definition as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<!-- Syntax elements data, DataSpec -->\n"},"threshold.range":{"desc":"<p>Set the <code class=\"codespan\">scale</code> value domain, which can be coordinates, colors, or other content</p>\n<p>There are three supported formats:</p>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by parsing specific data, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  data: string | IData;\n  field: string | string[];\n  sort?: (datumA: any, datumB: any) =&gt; number\n}\n</code></pre>\n<ul>\n<li>Custom function type, with the specific type defined as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">(scale: IBaseScale, parameters: any) =&gt; any;\n</code></pre>\n<ul>\n<li>Object type, setting the <code class=\"codespan\">range</code> value by binding with an axis of the coordinate system. In this case, the <code class=\"codespan\">range</code> corresponds to the coordinate range of a certain axis of the coordinate system. The specific configuration is as follows:</li>\n</ul>\n<pre><code class=\"lang-ts\">{\n  coordinate: string;\n  dimension: &#39;x&#39; | &#39;y&#39;;\n  isSubshaft?: boolean;\n  reversed?: boolean\n}\n</code></pre>\n"}}